Стратегии вычисления (Evaluation strategies)
============================================
Статья на [wikipedia][0]


Вызов по ссылке/значению
========================
В англоязычной литературе называется как Call by reference и Call by
value. Работает аналогично `Java` или `C#`. По ссылке передаются
наследники [`AnyRef`][1], по значению передаются наследники
[`AnyVal`][2]. Аргументы переданные функции одним из этих двух способов
будут вычислены в момент вызова данной функции. В отличии от Call by
name...


Call by name
============
Стратегия вычислений, при которой аргумент функции вычисляется каждый
раз когда его используют внутри тела функции. На данный момент лучшая
[статья][3], по субъективному мнению одного из авторов.
Так же, достаточно простое и понятное [объяснение][4].


Call by need
============
Стратегия вычислений, при которой аргументы вычисляются только тогда
когда впервые используются внутри тела функции. Представляет собой
[мемоизированный][memoization] вариант для Call by name. В явном виде в
`Scala` не используется, только как часть Call by name.


Call by future
==============
Стратегия вычислений, при которой аргументы функции выполняются
конкурентно внутри тела функции. В `Scala` присутствуют `Futures`,
поэтому подобная стратегия тоже имеет место быть.

[0]: https://en.wikipedia.org/wiki/Evaluation_strategy
[1]: http://www.scala-lang.org/api/current/scala/AnyRef.html
[2]: http://www.scala-lang.org/api/current/scala/AnyVal.html
[3]: https://tpolecat.github.io/2014/06/26/call-by-name.html
[4]: http://locrianmode.blogspot.ru/2011/07/scala-by-name-parameter.html

[memoization]: https://en.wikipedia.org/wiki/Memoization

