Функции высшего порядка / Каррирование
======================================

## Введение
Как вы могли заметить ранее, существует два способа [укзания типа][0]
функций в `Scala`:

 - с использованием дженериков: `f: Function2[Int, String, String]`
 - функциональный: `f: (Int, String) => String`

Использование конкретного типа зависит от ситуации. Однако, что в
первом, что во втором случае, тип функции сложно читать. Рекомендуется
связывать тип наиболее часто используемой функции с некоторым
псевдонимом, например:

    type Action = () => Unit

Выше продемонстрированна функция, которая не принимает, и не возвращает
аргументов. В случае если у вас используются дженерик-параметры, то
вполне допустимо использовать для `Function1` функциональный стиль прямо
на месте:

    def map[B](f: A => B) = ...

Указание типа функций не имеет смысла, в виду отсутствия возможности
принимать и передавать функции, но обо всем по порядку.

## О хороших функцияx
В лямбда-исчислении, функция должна принимать один аргумент и возвращать
один аргумент. Собственно функция должна [арность][2] 1. Поэтому в
некоторых языках отсутствуют функции, принимающие более одного
аргумента. Далее мы будем расказывать о функциях с арностью 1.

Композиция функций ([function composition][4]) это простейший и основной
способ комбинирования функций, основанный размещении функций таким
образом, что выход одной функции, является входом для другой. Давайте
рассмотрим две простые функции:

    def inc (x: Int) = x + 1
    def dup (x: Int) = x * 2

Задача перед нами стоит следующая, собрать функцию, которая принимает
целое число, добавляет к нему единицу, а затем удваивает.

    def incDup(x: Int) = dup(inc(x))

Собственно, выше только что была продемонмтрирована композиция функций.
Во многих функциональных языках, например в `Haskell` существует
поддержка особого синтаксиса для композиции функций:

    // Код на haskell
    // объявили функции
    Prelude> let inc x = x + 1
    Prelude> let dup x = x * 2

    // новая функция которая является результатом композиции
    // передача и просовывание x подразумеваются синтаксисом :)
    Prelude> let incDup = dup . inc

    // проверяем результат
    Prelude> incDup 3
    8

Давайте посмотрим на то, как это сделано в `SML`:

    (* Объявили наши функции *)
    - val inc = fn(x) => x + 1;
    val inc = fn : int -> int

    - val dup = fn(2) => x * 2;
    val dup = fn : int -> int

    (* подразумевается наличие неявного аргумента *)
    - val incDup = dup o inc;
    val incDup = fn : int -> int

    (* проверим результат *)
    - incDup 3;
    val it = 8 : int

`Scala` не является исключением, в ней тоже есть аналогичная операция,
которая, кстати применима только к типу `Function1`. Итак, перепишем
функцию incDup аналогичным образом:

    // Теперь Scala
    val incDup = dup _ compose inc _

    // Вобщем, как-то так, да
    incDup: Int => Int = scala.Function1$$Lambda$1098/1854577712@5d01ea21

    // Проверяем результат
    scala> incDup(3)
    res0: Int = 8

Скорее всего, вы уже заметили что данные конструкции следует читать
справа-налево. Не всем привычно, не всем удобно. Метод `andThen`
позволяет задавать порядок применения функций слева-направо:

    scala> val incDup2 = inc _ andThen dup _
    incDup2: Int => Int = scala.Function1$$Lambda$1112/312470853@23592946

    // Проверяем еще раз
    scala> incDup2(3)
    res4: Int = 8


## Функции высшего порядка (High order functions)

TODO: провести аналогии с явовскими замыаканиями


## Каррирование (Currying)

    f: Int => String => Boolean => Double


## Замыкания (Closures)




Литература
==========
[0]: http://docs.scala-lang.org/style/types.html#function-values
[1]: https://en.wikipedia.org/wiki/Arity
[2]: http://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html#composition


[4]: https://en.wikipedia.org/wiki/Function_composition_(computer_science)
[5]: https://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html#composition

[curry-0]: https://en.wikibooks.org/wiki/Scala/Currying
[curry-1]: https://twitter.github.io/scala_school/pattern-matching-and-functional-composition.html#curryvspartial
